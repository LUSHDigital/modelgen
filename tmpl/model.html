{{define "model"}}
package {{ .PackageName }}

/*---------------------------+
| Code generated by modelgen |
|        DO NOT EDIT.        |
+---------------------------*/

// If you want to extend behaviour:
// Please create a custom file in this directory
// and create the methods there to avoid overwriting your code with the generated one.

import (
    "fmt"
    "strconv"
    "database/sql"
    {{ range $k, $v:= .Model.Imports }}
    "{{$k}}"
    {{- end }}
)

// {{.Model.Name}} represents a row in the {{.Model.TableName}} table
type {{.Model.Name}} struct {
    {{ range $k, $v:= .Model.Fields }}
        {{ $v.Name }} {{ $v.Type }} `json:"{{$v.ColumnName}}"`
    {{- end }}
offset int
limit int
}

// {{.Model.Name}}SelectFields is a SELECT-friendly list of all fields.
var {{.Model.Name}}SelectFields = `{{ . | select_fields }}`

// Insert a new {{.Model.Name}} row in the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Insert(qu Queryer) (lastInsertID int64, err error) {
    const stmt = `INSERT INTO "{{.Model.TableName}}" ({{.Model.Fields | insert_fields}}) VALUES ({{.Model.Fields | insert_values}}) RETURNING id`
    row := qu.QueryRow(stmt, {{ . | insert_args }})
    err = row.Scan(&lastInsertID)
	return
}

// Update an existing {{.Model.Name}} row in the {{.Model.TableName}} table.
func ({{.Receiver}} *{{.Model.Name}}) Update(qu Queryer, id int64) (int64, error) {
    const stmt = `UPDATE "{{.Model.TableName}}" SET {{ . | update_values }} WHERE id = {{ . | update_values_size }}`
    result, err := qu.Exec(stmt, {{ . | update_args }} , id)
    if err != nil {
        return 0, err
    }
    return result.RowsAffected()
}

// Find an existing {{.Model.Name}} row in the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Find(qu Queryer, id int64) error {
    const stmt = `SELECT {{ . | select_fields }} FROM "{{.Model.TableName}}" {{.Receiver}} WHERE id = $1`
    row := qu.QueryRow(stmt, id)
    return {{.Receiver}}.ScanRow(row)
}

// Load all, or a subset of {{.Model.Name}} rows from the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Load(qu Queryer) (set []{{.Model.Name}}, err error) {
    stmt := `SELECT {{ . | select_fields }} FROM "{{.Model.TableName}}" {{.Receiver}}`

    if {{.Receiver}}.limit == 0 && {{.Receiver}}.offset > 0 {
        return set, fmt.Errorf("cannot query with offset but no limit")
    }

    if {{.Receiver}}.limit > 0 {
        stmt += fmt.Sprintf(" LIMIT %d", {{.Receiver}}.limit)
    }
    if {{.Receiver}}.offset > 0 {
        stmt += fmt.Sprintf(" OFFSET %d", {{.Receiver}}.offset)
    }
    defer func() {
        {{.Receiver}}.limit = 0
        {{.Receiver}}.offset = 0
    }()
    rows, err := qu.Query(stmt)
    if err != nil {
        return
    }
    defer rows.Close()
        for rows.Next() {
            if err = {{.Receiver}}.ScanRows(rows); err != nil {
            return
        }
        set = append(set, *{{.Receiver}})
    }

    return
}

// Delete an existing {{.Model.Name}} row from the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Delete(qu Queryer, id int64) (rowsAffected int64, err error) {
    const stmt = `DELETE FROM "{{.Model.TableName}}" WHERE id = $1`
    result, err := qu.Exec(stmt, id)
	if err != nil {
		return
	}

	return result.RowsAffected()
}

// Count the number of rows from the {{.Model.TableName}} table
func({{.Receiver}} *{{.Model.Name}}) Count(qu Queryer) (count int64, err error) {
    const stmt = `SELECT COUNT(*) FROM "{{.Model.TableName}}"`
    row := qu.QueryRow(stmt)
    if err = row.Scan(&count); err != nil {
        return
    }
    return
}

// Exists checks for the items existence in the database, based on it's id.
// An error will only be returned if a SQL related failure happens.
// In all other cases, a bool and nil will return.
func({{.Receiver}} *{{.Model.Name}}) Exists(qu Queryer, id int64) (exists bool, err error) {
    const stmt = `SELECT EXISTS(SELECT 1 FROM "{{.Model.TableName}}" WHERE id = $1 LIMIT 1) AS "exists"`
    row := qu.QueryRow(stmt, id)
    if err = row.Scan(&exists); err != nil {
        return
    }
    return
}

// ScanRows scans columns into struct fields from a db.Query().
func ({{.Receiver}} *{{.Model.Name}}) ScanRows(rows *sql.Rows) error {
    return rows.Scan({{. | scan_fields}});
}

// ScanRow scans columns into struct fields from a db.QueryRow().
func ({{.Receiver}} *{{.Model.Name}}) ScanRow(row *sql.Row) error {
    return row.Scan({{. | scan_fields}});
}

// TableName returns the table name
func ({{.Receiver}} *{{.Model.Name}}) TableName() string {
    return "{{.Model.TableName}}"
}

// SetLimit sets the query limit
func ({{.Receiver}} *{{.Model.Name}}) SetLimit(limit int) *{{.Model.Name}} {
    {{.Receiver}}.limit = limit
    return {{.Receiver}}
}

// SetOffset sets the query offset
func ({{.Receiver}} *{{.Model.Name}}) SetOffset(offset int) *{{.Model.Name}} {
    {{.Receiver}}.offset = offset
    return {{.Receiver}}
}

// LimitExpr returns a common table expression allowing limit and offset to be
// used in a join statement.
func ({{.Receiver}} *{{.Model.Name}}) LimitExpr(stmt string) string {
    var limit string
	if {{.Receiver}}.limit > 0 {
		limit = strconv.FormatInt(int64({{.Receiver}}.limit), 10)
	} else {
		limit = "ALL"
    }
    return fmt.Sprintf(
        `WITH lim AS (SELECT * FROM "{{.Model.TableName}}" LIMIT %s OFFSET %d) %s`,
        limit,
        {{.Receiver}}.offset,
        stmt)
}
{{end}}
