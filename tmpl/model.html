{{define "model"}}
package {{ .PackageName }}

/*---------------------------+
| Code generated by modelgen |
|        DO NOT EDIT.        |
+---------------------------*/

// If you want to extend behaviour:
// Please create a custom file in this directory
// and create the methods there to avoid overwriting your code with the generated one.

import (
"fmt"
"database/sql"
    {{ range $k, $v:= .Model.Imports }}
    "{{$k}}"
    {{- end }}
)

// {{.Model.Name}} represents a row in the {{.Model.TableName}} table
type {{.Model.Name}} struct {
    {{ range $k, $v:= .Model.Fields }}
        {{ $v.Name }} {{ $v.Type }} `json:"{{$v.ColumnName}}"`
    {{- end }}
offset int
limit int
}

// Insert a new {{.Model.Name}} row in the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Insert(db *sql.DB) (lastInsertID int64, err error) {
    const stmt = "INSERT INTO {{.Model.TableName}} ({{.Model.Fields | insert_fields}}) VALUES ({{.Model.Fields | insert_values}})"
    res, err := db.Exec(stmt, {{ . | insert_args }})
    if err != nil {
        return 0, err
    }
    return res.LastInsertId()
}

// Update an existing {{.Model.Name}} row in the {{.Model.TableName}} table.
func ({{.Receiver}} *{{.Model.Name}}) Update(db *sql.DB, id int64) (int64, error) {
    const stmt = "UPDATE {{.Model.TableName}} SET {{ . | update_values }} WHERE id = ?"
    result, err := db.Exec(stmt, {{ . | update_args }} , id)
    if err != nil {
        return 0, err
    }
    return result.RowsAffected()
}

// Find an existing {{.Model.Name}} row in the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Find(db *sql.DB, id int64) error {
    const stmt = "SELECT * FROM {{.Model.TableName}} WHERE id = ?"
    row := db.QueryRow(stmt, id)
    return row.Scan({{ . | scan_fields}})
}

// Load all, or a subset of {{.Model.Name}} rows from the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Load(db *sql.DB) (set []{{.Model.Name}}, err error) {
    stmt := "SELECT * FROM {{.Model.TableName}}"

    if {{.Receiver}}.limit == 0 && {{.Receiver}}.offset > 0 {
        return set, fmt.Errorf("cannot query with offset but no limit")
    }

    if {{.Receiver}}.limit > 0 {
        stmt += fmt.Sprintf(" LIMIT %d", {{.Receiver}}.limit)
    }
    if {{.Receiver}}.offset > 0 {
        stmt += fmt.Sprintf(" OFFSET %d", {{.Receiver}}.offset)
    }
    defer func() {
        {{.Receiver}}.limit = 0
        {{.Receiver}}.offset = 0
    }()
    rows, err := db.Query(stmt)
    if err != nil {
        return
    }
    defer rows.Close()
        for rows.Next() {
            if err = rows.Scan({{. | scan_fields}}); err != nil {
            return
        }
        set = append(set, *{{.Receiver}})
    }

    return
}

// Delete an existing {{.Model.Name}} row from the {{.Model.TableName}} table
func ({{.Receiver}} *{{.Model.Name}}) Delete(db *sql.DB, id int64) (rowsAffected int64, err error) {
    const stmt = "DELETE FROM {{.Model.TableName}} WHERE id = ?"
    result, err := db.Exec(stmt, id)
	if err != nil {
		return
	}

	return result.RowsAffected()
}

// Count the number of rows from the {{.Model.TableName}} table
func({{.Receiver}} *{{.Model.Name}}) Count(db *sql.DB) (count int64, err error) {
    const stmt = "SELECT COUNT(*) FROM {{.Model.TableName}}"
    row := db.QueryRow(stmt)
    if err = row.Scan(&count); err != nil {
        return
    }
    return
}

// Exists checks for the items existence in the database, based on it's id.
// An error will only be returned if a SQL related failure happens.
// In all other cases, a bool and nil will return.
func({{.Receiver}} *{{.Model.Name}}) Exists(db *sql.DB, id int64) (exists bool, err error) {
    const stmt = "SELECT EXISTS(SELECT 1 FROM {{.Model.TableName}} WHERE id = ? LIMIT 1) AS `exists`"
    var count int
    row := db.QueryRow(stmt, id)
    if err = row.Scan(&count); err != nil {
        return
    }
    return count > 0, nil
}

// TableName returns the table name
func ({{.Receiver}} *{{.Model.Name}}) TableName() string {
    return "{{.Model.TableName}}"
}

// SetLimit sets the query limit
func ({{.Receiver}} *{{.Model.Name}}) SetLimit(limit int) *{{.Model.Name}} {
    {{.Receiver}}.limit = limit
    return {{.Receiver}}
}

// SetOffset sets the query offset
func ({{.Receiver}} *{{.Model.Name}}) SetOffset(offset int) *{{.Model.Name}} {
    {{.Receiver}}.offset = offset
    return {{.Receiver}}
}
{{end}}

